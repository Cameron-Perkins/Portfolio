#include <iostream>
#include <math.h>

// function to add the elements of two arrays
__global__ void Multiply(int *a, int row1, int col1 ,int *b, int row2, int col2, int *c)
{
 for (int i = 0; i < row1; i++){
     for (int j = 0; j < col2; j++){
         int sum = 0;
         for(int k = 0; k < col1; k++){
             sum = sum + a[i * col1 + k] * b[k * col2 + j];
        c[i * col2 + j] = sum;
            }
        }
    }
}
 
int main(void)
{
 int row1 = 2;
 int col1 = 4;
 int row2 = 3;
 int col2 = 4;
 int *x = new int[row1*col1];
 int *y = new int[row2*col2];
 int *c = new int[row1*col1];
 int d_c[9];

    int N1 = row1*col1;
    int N2 = row2*col2;
    int N3 = row1*col2;

    cudaMallocManaged(&x, N1*sizeof(int));
    cudaMallocManaged(&y, N2*sizeof(int));
    cudaMallocManaged(&c, N3*sizeof(int));

    cudaMemcpy(d_c, c, N3*sizeof(int), cudaMemcpyHostToDevice);

 // initialize x on the host
 for (int i = 0; i <= row1*col2; i++) {
    x[i] = 1;
 }

 // initialize y on the host
 for (int i = 0; i <= row2*col2; i++){
     y[i] = 2;
 }
 for (int i = 0; i <= row1*col2; i++){
     c[i] = 3;
 }
 
 int blockSize = 256;
 int numBlocks = (N + blockSize - 1) / blockSize;
 // Run kernel on 1M elements on the CPU
// int *a, int row1, int col1 ,int *b, int row2, int col2, int *c) 
 Multiply<<<numBlocks,blockSize>>>(x, 3, 3 ,y, 3, 3 ,c);
 cudaDeviceSynchronize();

for(int i = 0; i < 9; i++){
    std::cout << c[i] << ' ';
}
 
 // Check for errors (all values should be 3.0f)
 float maxError = 0.0f;
 for (int i = 0; i < N; i++)
   maxError = fmax(maxError, fabs(y[i]-3.0f));
 std::cout << "Max error: " << maxError << std::endl;



 // Free memory
 delete [] x;
 delete [] y;
 delete [] c;
 return 0;
}
